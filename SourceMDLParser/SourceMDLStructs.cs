using SourceFormatParser.Common;
using System;
using System.Collections.Generic;

namespace SourceFormatParser.MDL
{
	public static class SourceMDLStructs
	{
		public const int IDMDLHEADER = (('T' << 24) + ('S' << 16) + ('D' << 8) + 'I');

		#region enums
		[Flags]
		public enum studiohdrFlags
		{
			// This flag is set if no hitbox information was specified
			STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX = (1 << 0),

			// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
			// models when we change materials.
			STUDIOHDR_FLAGS_USES_ENV_CUBEMAP = (1 << 1),

			// Use this when there are translucent parts to the model but we're not going to sort it 
			STUDIOHDR_FLAGS_FORCE_OPAQUE = (1 << 2),

			// Use this when we want to render the opaque parts during the opaque pass
			// and the translucent parts during the translucent pass
			STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS = (1 << 3),

			// This is set any time the .qc files has $staticprop in it
			// Means there's no bones and no transforms
			STUDIOHDR_FLAGS_STATIC_PROP = (1 << 4),

			// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
			// models when we change materials.
			STUDIOHDR_FLAGS_USES_FB_TEXTURE = (1 << 5),

			// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
			//  for the .mdl (the shadow lod is the last entry in the lod list if present)
			STUDIOHDR_FLAGS_HASSHADOWLOD = (1 << 6),

			// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
			// models when we change materials.
			STUDIOHDR_FLAGS_USES_BUMPMAPPING = (1 << 7),

			// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
			// instead of overriding them with the default one (necessary for translucent shadows)
			STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS = (1 << 8),

			// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
			// instead of overriding them with the default one (necessary for translucent shadows)
			STUDIOHDR_FLAGS_OBSOLETE = (1 << 9),

			// NOTE:  This flag is set when we need to draw in the additive stage of the deferred rendering
			STUDIOHDR_FLAGS_NEEDS_DEFERRED_ADDITIVE = (1 << 10),

			// NOTE:  This flag is set at mdl build time
			STUDIOHDR_FLAGS_NO_FORCED_FADE = (1 << 11),

			// NOTE:  The npc will lengthen the viseme check to always include two phonemes
			STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE = (1 << 12),

			// This flag is set when the .qc has $constantdirectionallight in it
			// If set, we use constantdirectionallightdot to calculate light intensity
			// rather than the normal directional dot product
			// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
			STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT = (1 << 13),

			// Flag to mark delta flexes as already converted from disk format to memory format
			STUDIOHDR_FLAGS_FLEXES_CONVERTED = (1 << 14),

			// Indicates the studiomdl was built in preview mode
			STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE = (1 << 15),

			// Ambient boost (runtime flag)
			STUDIOHDR_FLAGS_AMBIENT_BOOST = (1 << 16),

			// Don't cast shadows from this model (useful on first-person models)
			STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS = (1 << 17),

			// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
			STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS = (1 << 18),

			// Model has a quad-only Catmull-Clark SubD cage
			STUDIOHDR_FLAGS_SUBDIVISION_SURFACE = (1 << 19),

			// flagged on load to indicate no animation events on this model
			STUDIOHDR_FLAGS_NO_ANIM_EVENTS = (1 << 20),

			// If flag is set then studiohdr_t.flVertAnimFixedPointScale contains the
			// scale value for fixed point vert anim data, if not set then the
			// scale value is the default of 1.0 / 4096.0.  Regardless use
			// studiohdr_t::VertAnimFixedPointScale() to always retrieve the scale value
			STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE = (1 << 21),

			// If flag is set then model data is processed for EDGE
			// the flag is set at tool time when producing PS3-format assets
			STUDIOHDR_FLAGS_PS3_EDGE_FORMAT = (1 << 22),

			// this is a specific case to indicate a model is over budget
			STUDIOHDR_FLAGS_OVER_BUDGET = (1 << 23),

			// this is a specific case to indicate a model is over budget
			STUDIOHDR_FLAGS_IGNORE_BUDGETS = (1 << 24),

			// internally generated combined model
			STUDIOHDR_FLAGS_COMBINED = (1 << 25),

			// Model has an additional set of UVs
			STUDIOHDR_FLAGS_EXTRA_VERTEX_DATA = (1 << 26),

			// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
			// models when we change materials.
			STUDIOHDR_BAKED_VERTEX_LIGHTING_IS_INDIRECT_ONLY = (1 << 27)
		}
		#endregion

		#region structs
		/// <summary>SourceMDL header. Size: 408 bytes.
		/// TO DO: virtualmodel_t / </summary>
		public struct studiohdr_t
		{
			public int id;
			public int version;

			public int checksum;       // this has to be the same in the phy and vtx files to load!

			//inline const char* pszName( void ) const { if (studiohdr2index && pStudioHdr2()->pszName()) return pStudioHdr2()->pszName(); else return name; }
			public string name; //char[64];

			public int length;

			public SourceVector eyeposition; // ideal eye position

			public SourceVector illumposition;   // illumination center

			public SourceVector hull_min;        // ideal movement hull size
			public SourceVector hull_max;

			public SourceVector view_bbmin;      // clipping bounding box
			public SourceVector view_bbmax;

			public int flags;

			public int numbones;           // bones
			public int boneindex;

			public int numbonecontrollers;     // bone controllers
			public int bonecontrollerindex;

			public int numhitboxsets;
			public int hitboxsetindex;

			// Look up hitbox set by index
			//	mstudiohitboxset_t* pHitboxSet(int i) const
			//	{ 
			//	Assert(i >= 0 && i<numhitboxsets); 
			//	return (mstudiohitboxset_t*) (((byte*)this) + hitboxsetindex ) + i;
			//	};

			//	// Calls through to hitbox to determine size of specified set
			//	inline mstudiobbox_t *pHitbox(int i, int set) const
			// 	{ 
			//	mstudiohitboxset_t const * s = pHitboxSet(set);
			//	if ( !s )
			//		return NULL;

			//	return s->pHitbox(i );
			//};


			// Calls through to set to get hitbox count for set
			//inline int iHitboxCount(int set) const
			//{
			//	mstudiohitboxset_t const * s = pHitboxSet(set);
			//	if ( !s )
			//		return 0;

			//	return s->numhitboxes;
			//};

			// file local animations? and sequences
			//private:
			public int numlocalanim;           // animations/poses
			public int localanimindex;     // animation descriptions
										   //inline mstudioanimdesc_t * pLocalAnimdesc(int i) const { if (i< 0 || i >= numlocalanim) i = 0; return (mstudioanimdesc_t*) (((byte*)this) + localanimindex) + i; };

			public int numlocalseq;                // sequences
			public int localseqindex;
			//inline mstudioseqdesc_t * pLocalSeqdesc(int i) const { if (i< 0 || i >= numlocalseq) i = 0; return (mstudioseqdesc_t*) (((byte*)this) + localseqindex) + i; };

			//public:
			//bool SequencesAvailable() const;
			//int GetNumSeq_Internal() const;
			//inline int GetNumSeq() const
			//	{
			//		if (numincludemodels == 0)
			//		{
			//			return numlocalseq;
			//		}
			//		return GetNumSeq_Internal();

			//	}
			//	mstudioanimdesc_t	&pAnimdesc_Internal(int i) const;
			//inline mstudioanimdesc_t &pAnimdesc(int i) const
			//	{
			//		if (numincludemodels == 0)
			//		{
			//			return * pLocalAnimdesc(i );
			//		}

			//		return pAnimdesc_Internal(i );
			//	}

			//	mstudioseqdesc_t	&pSeqdesc_Internal(int i) const;
			//inline mstudioseqdesc_t &pSeqdesc(int i) const
			//	{
			//		if (numincludemodels == 0)
			//		{
			//			return * pLocalSeqdesc(i );
			//		}
			//		return pSeqdesc_Internal(i );
			//	}
			//	int iRelativeAnim_Internal(int baseseq, int relanim) const; // maps seq local anim reference to global anim index
			//inline int iRelativeAnim(int baseseq, int relanim) const
			//	{
			//		if (numincludemodels == 0 )
			//			return relanim;
			//		return iRelativeAnim_Internal(baseseq, relanim );
			//	}
			//	int iRelativeSeq_Internal(int baseseq, int relseq) const;       // maps seq local seq reference to global seq index
			//inline int iRelativeSeq(int baseseq, int relseq) const
			//	{
			//		if (numincludemodels == 0)
			//		{
			//			return relseq;
			//		}
			//		return iRelativeSeq_Internal(baseseq, relseq );
			//	}

			//private:
			public int activitylistversion;    // initialization flag - have the sequences been indexed?
			public int eventsindexed;
			//public:
			//int GetSequenceActivity(int iSequence);
			//void SetSequenceActivity(int iSequence, int iActivity);
			//int GetActivityListVersion(void );
			//void SetActivityListVersion(int version) const;
			//int GetEventListVersion(void );
			//void SetEventListVersion(int version);

			// raw textures
			public int numtextures;
			public int textureindex;
			//inline mstudiotexture_t * pTexture(int i) const { Assert(i >= 0 && i<numtextures ); return (mstudiotexture_t*) (((byte*)this) + textureindex) + i; };


			// raw textures search paths
			public int numcdtextures;
			public int cdtextureindex;
			//inline char* pCdtexture(int i) const { return (((char*)this) + *((int *)(((byte *)this) + cdtextureindex) + i)); };

			// replaceable textures tables
			public int numskinref;
			public int numskinfamilies;
			public int skinindex;
			//inline short* pSkinref(int i) const { return (short*) (((byte*)this) + skinindex) + i; };

			public int numbodyparts;
			public int bodypartindex;
			//inline mstudiobodyparts_t   * pBodypart(int i) const { return (mstudiobodyparts_t*) (((byte*)this) + bodypartindex) + i; };

			// queryable attachable points
			//private:
			public int numlocalattachments;
			public int localattachmentindex;
			//inline mstudioattachment_t  * pLocalAttachment(int i) const { Assert(i >= 0 && i<numlocalattachments); return (mstudioattachment_t*) (((byte*)this) + localattachmentindex) + i; };
			//public:
			//int GetNumAttachments(void ) const;
			//const mstudioattachment_t &pAttachment(int i) const;
			//int GetAttachmentBone(int i);
			// used on my tools in hlmv, not persistant
			//void SetAttachmentBone(int iAttachment, int iBone);

			// animation node to animation node transition graph
			//private:
			public int numlocalnodes;
			public int localnodeindex;
			public int localnodenameindex;
			//inline char* pszLocalNodeName(int iNode) const { Assert(iNode >= 0 && iNode<numlocalnodes); return (((char*)this) + *((int *)(((byte *)this) + localnodenameindex) + iNode)); }
			//inline byte* pLocalTransition(int i) const { Assert(i >= 0 && i<(numlocalnodes* numlocalnodes)); return (byte*) (((byte*)this) + localnodeindex) + i; };

			//public:
			//int EntryNode(int iSequence);
			//int ExitNode(int iSequence);
			//char* pszNodeName(int iNode);
			//int GetTransition(int iFrom, int iTo) const;

			public int numflexdesc;
			public int flexdescindex;
			//inline mstudioflexdesc_t * pFlexdesc(int i) const { Assert(i >= 0 && i<numflexdesc); return (mstudioflexdesc_t*) (((byte*)this) + flexdescindex) + i; };

			public int numflexcontrollers;
			public int flexcontrollerindex;
			//inline mstudioflexcontroller_t * pFlexcontroller(LocalFlexController_t i) const { Assert(i >= 0 && i<numflexcontrollers); return (mstudioflexcontroller_t*) (((byte*)this) + flexcontrollerindex) + i; };

			public int numflexrules;
			public int flexruleindex;
			//inline mstudioflexrule_t * pFlexRule(int i) const { Assert(i >= 0 && i<numflexrules); return (mstudioflexrule_t*) (((byte*)this) + flexruleindex) + i; };

			public int numikchains;
			public int ikchainindex;
			//inline mstudioikchain_t * pIKChain(int i) const { Assert(i >= 0 && i<numikchains); return (mstudioikchain_t*) (((byte*)this) + ikchainindex) + i; };

			public int nummouths;
			public int mouthindex;
			//inline mstudiomouth_t * pMouth(int i) const { Assert(i >= 0 && i<nummouths); return (mstudiomouth_t*) (((byte*)this) + mouthindex) + i; };

			//private:
			public int numlocalposeparameters;
			public int localposeparamindex;
			//inline mstudioposeparamdesc_t * pLocalPoseParameter(int i) const { Assert(i >= 0 && i<numlocalposeparameters); return (mstudioposeparamdesc_t*) (((byte*)this) + localposeparamindex) + i; };
			//public:
			//int GetNumPoseParameters(void ) const;
			//const mstudioposeparamdesc_t &pPoseParameter(int i);
			//int GetSharedPoseParameter(int iSequence, int iLocalPose) const;

			public int surfacepropindex;
			//inline char* const pszSurfaceProp( void ) const { return ((char*)this) + surfacepropindex; }
			//inline int GetSurfaceProp() const { return surfacepropLookup; }

			// Key values
			public int keyvalueindex;
			public int keyvaluesize;
			//inline const char* KeyValueText( void ) const { return keyvaluesize != 0 ? ((char*)this) + keyvalueindex : NULL; }

			public int numlocalikautoplaylocks;
			public int localikautoplaylockindex;
			//inline mstudioiklock_t * pLocalIKAutoplayLock(int i) const { Assert(i >= 0 && i<numlocalikautoplaylocks); return (mstudioiklock_t*) (((byte*)this) + localikautoplaylockindex) + i; };

			//int GetNumIKAutoplayLocks(void ) const;
			//const mstudioiklock_t &pIKAutoplayLock(int i);
			//int CountAutoplaySequences() const;
			//int CopyAutoplaySequences(unsigned short* pOut, int outCount) const;
			//int GetAutoplayList(unsigned short** pOut) const;

			// The collision model mass that jay wanted
			public float mass;
			public int contents;

			// external animations, models, etc.
			public int numincludemodels;
			public int includemodelindex;
			//inline mstudiomodelgroup_t * pModelGroup(int i) const { Assert(i >= 0 && i<numincludemodels); return (mstudiomodelgroup_t*) (((byte*)this) + includemodelindex) + i; };
			// implementation specific call to get a named model
			//const studiohdr_t* FindModel( void **cache, char const *modelname ) const;

			// implementation specific back pointer to virtual data. Relocated to studiohdr2_t
			//public int unused_virtualModel;

			//virtualmodel_t* GetVirtualModel(void ) const;

			// for demand loaded animation blocks
			public int szanimblocknameindex;
			//inline char* const pszAnimBlockName( void ) const { return ((char*)this) + szanimblocknameindex; }
			public int numanimblocks;
			public int animblockindex;
			//inline mstudioanimblock_t * pAnimBlock(int i) const { Assert(i > 0 && i<numanimblocks); return (mstudioanimblock_t*) (((byte*)this) + animblockindex) + i; };

			// Relocated to studiohdr2_t
			public int unused_animblockModel;

			//byte* GetAnimBlock(int i, bool preloadIfMissing = true) const;
			//bool hasAnimBlockBeenPreloaded(int i) const;

			public int bonetablebynameindex;
			//inline const byte* GetBoneTableSortedByName() const { return (byte*) this + bonetablebynameindex; }

			// used by tools only that don't cache, but persist mdl's peer data
			// engine uses virtualModel to back link to cache pointers
			// Relocated to studiohdr2_t
			//public int unused_pVertexBase;
			//public int unused_pIndexBase;

			// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
			// this value is used to calculate directional components of lighting 
			// on static props
			public byte constdirectionallightdot;

			// set during load of mdl data to track *desired* lod configuration (not actual)
			// the *actual* clamped root lod is found in studiohwdata
			// this is stored here as a global store to ensure the staged loading matches the rendering
			public byte rootLOD;

			// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
			// to be set as root LOD:
			//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
			//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
			public byte numAllowedRootLODs;

			//public byte unused;//[1];

			//public int unused4; // zero out if version < 47

			public int numflexcontrollerui;
			public int flexcontrolleruiindex;
			//mstudioflexcontrollerui_t* pFlexControllerUI(int i) const { Assert(i >= 0 && i<numflexcontrollerui); return (mstudioflexcontrollerui_t*) (((byte*)this) + flexcontrolleruiindex) + i; }

			public float flVertAnimFixedPointScale;
			//inline float VertAnimFixedPointScale() const { return (flags & STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE ) ? flVertAnimFixedPointScale : 1.0f / 4096.0f; }

			public int surfacepropLookup;  // this index must be cached by the loader, not saved in the file

			// FIXME: Remove when we up the model version. Move all fields of studiohdr2_t into studiohdr_t.
			public int studiohdr2index;
			//studiohdr2_t* pStudioHdr2() const { return (studiohdr2_t*) (((byte*)this ) + studiohdr2index ); }

			// Src bone transforms are transformations that will convert .dmx or .smd-based animations into .mdl-based animations
			//int NumSrcBoneTransforms() const { return studiohdr2index? pStudioHdr2()->numsrcbonetransform : 0; }
			//const mstudiosrcbonetransform_t* SrcBoneTransform( int i ) const { Assert(i >= 0 && i<NumSrcBoneTransforms()); return (mstudiosrcbonetransform_t*) (((byte*)this) + pStudioHdr2()->srcbonetransformindex) + i; }

			//inline int IllumPositionAttachmentIndex() const { return studiohdr2index? pStudioHdr2()->IllumPositionAttachmentIndex() : 0; }

			//inline float MaxEyeDeflection() const { return studiohdr2index? pStudioHdr2()->MaxEyeDeflection() : 0.866f; } // default to cos(30) if not set

			//inline mstudiolinearbone_t * pLinearBones() const { return studiohdr2index? pStudioHdr2()->pLinearBones() : NULL; }

			//inline int BoneFlexDriverCount() const { return studiohdr2index? pStudioHdr2()->m_nBoneFlexDriverCount : 0; }
			//inline const mstudioboneflexdriver_t* BoneFlexDriver( int i ) const { Assert(i >= 0 && i<BoneFlexDriverCount() ); return studiohdr2index? pStudioHdr2()->pBoneFlexDriver(i ) : NULL; }

			//	inline int BodyGroupPresetCount() const { return studiohdr2index? pStudioHdr2()->m_nBodyGroupPresetCount : 0; }
			//	inline const mstudiobodygrouppreset_t* BodyGroupPreset( int i ) const { Assert(i >= 0 && i<BodyGroupPresetCount() ); return studiohdr2index? pStudioHdr2()->pBodyGroupPreset(i ) : NULL; }

			//	void* VirtualModel() const { return studiohdr2index? (void*) (pStudioHdr2()->virtualModel ) : nullptr; }
			//	void SetVirtualModel(void* ptr) { Assert(studiohdr2index); if (studiohdr2index) { pStudioHdr2()->virtualModel = ptr; } }

			//void* VertexBase() const { return studiohdr2index? (void*) (pStudioHdr2()->pVertexBase ) : nullptr; }
			//	void SetVertexBase(void* pVertexBase) const { Assert(studiohdr2index ); if (studiohdr2index ) { pStudioHdr2()->pVertexBase = pVertexBase; } }
			//	void* IndexBase() const { return studiohdr2index? (void* ) (pStudioHdr2()->pIndexBase ) : nullptr; }
			//	void SetIndexBase(void* pIndexBase) const { Assert(studiohdr2index ); if (studiohdr2index ) { pStudioHdr2()->pIndexBase  = pIndexBase; } }


			// NOTE: No room to add stuff? Up the .mdl file format version 
			// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
			// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
			//public int unused2;//[1];

			//additional
			public studiohdrFlags[] getFlags => FlagsUtils.getFlags<studiohdrFlags>(flags);
			public mstudiobone_t[] pBone; //[numbones] (boneindex + i * size) //by antim: may be helpful "bonesetup/bone_decode.cpp":253 (method CalcBoneQuaternion) or something else
			public mstudiobonecontroller_t[] pBonecontroller; //[numbonecontrollers] (bonecontrollerindex + i * size);

			public virtualmodel_t GetVirtualModel()
			{
				if (numincludemodels == 0)
					return null;
				throw new NotImplementedException();
				//return modelinfo.GetVirtualModel(this);
			}
			public int RemapSeqBone(int iSequence, int iLocalBone)  // maps local sequence bone to global bone
			{
				// remap bone
				virtualmodel_t pVModel = GetVirtualModel();
				if (pVModel != null)
				{
					virtualgroup_t pSeqGroup = pVModel.pSeqGroup(iSequence);
					return pSeqGroup.masterBone[iLocalBone];
				}
				return iLocalBone;
			}
			public int RemapAnimBone(int iAnim, int iLocalBone)     // maps local animations bone to global bone
			{
				// remap bone
				virtualmodel_t pVModel = GetVirtualModel();
				if (pVModel != null)
				{
					virtualgroup_t pAnimGroup = pVModel.pAnimGroup(iAnim);
					return pAnimGroup.masterBone[iLocalBone];
				}
				return iLocalBone;
			}
		}

		/// <summary>SourceMDL 2nd header. Size: 187 bytes.</summary>
		public struct studiohdr2_t
		{
			// NOTE! Next time we up the .mdl file format, remove studiohdr2_t
			// and insert all fields in this structure into studiohdr_t.

			// NOTE: For forward compat, make sure any methods in this struct
			// are also available in studiohdr_t so no leaf code ever directly references
			// a studiohdr2_t structure
			public int numsrcbonetransform;
			public int srcbonetransformindex;

			public int illumpositionattachmentindex;
			//inline int IllumPositionAttachmentIndex() const { return illumpositionattachmentindex; }

			public float flMaxEyeDeflection;
			//inline float MaxEyeDeflection() const { return flMaxEyeDeflection != 0.0f ? flMaxEyeDeflection : 0.866f; } // default to cos(30) if not set

			public int linearboneindex;
			//inline mstudiolinearbone_t * pLinearBones() const { return (linearboneindex)? (mstudiolinearbone_t*) (((byte*)this) + linearboneindex) : NULL; }

			public int sznameindex;
			//inline char* pszName() { return (sznameindex) ? (char*)(((byte*)this) + sznameindex) : NULL; }

			public int m_nBoneFlexDriverCount;
			public int m_nBoneFlexDriverIndex;
			//inline mstudioboneflexdriver_t * pBoneFlexDriver(int i) const { Assert(i >= 0 && i<m_nBoneFlexDriverCount ); return (mstudioboneflexdriver_t*) (((byte*)this) + m_nBoneFlexDriverIndex) + i; }

			//CResourcePointer<PhysFeModelDesc_t> m_pFeModel; // this is functionally the same as having an index and a function, but more readable.

			public int m_nBodyGroupPresetCount;
			public int m_nBodyGroupPresetIndex;
			//inline mstudiobodygrouppreset_t * pBodyGroupPreset(int i) const { Assert(i >= 0 && i<m_nBodyGroupPresetCount); return (mstudiobodygrouppreset_t*) (((byte*)this) + m_nBodyGroupPresetIndex) + i; };

			public int padding_unused; // This hasn't been used before, use it if you need it.
									   //by antim: "padding_unused" is used in 2018>/s version of CSGO, idk where it used.

			//mutable serializedstudioptr_t< void	> virtualModel;
			//mutable serializedstudioptr_t< void	> animblockModel;

			//serializedstudioptr_t<void> pVertexBase;
			//serializedstudioptr_t<void> pIndexBase;

			//public int[] reserved;//[44];
		}

		/// <summary>Bone. Size: 216 bytes.</summary>
		public struct mstudiobone_t
		{
			public int sznameindex;
			public int parent;     // parent bone
			public int[] bonecontroller;//[6];  // bone controller index, -1 == none

			// default values
			public SourceVector pos;
			public SourceQuaternion quat;
			public SourceRadianEuler rot;
			// compression scale
			public SourceVector posscale;
			public SourceVector rotscale;

			public SourceMatrix3x4 poseToBone;
			public SourceQuaternion qAlignment;
			public int flags;
			public int proctype;
			public int procindex;      // procedural rule
			public int physicsbone;    // index into physically simulated bone
									   //inline void* pProcedure() const { if (procindex == 0) return NULL; else return  (void*) (((byte*)this) + procindex); };
			public int surfacepropidx; // index into string tablefor property name

			public int contents;       // See BSPFlags.h for the contents flags
			public int surfacepropLookup;  // this index must be cached by the loader, not saved in the file

			//public int[] unused;//[7];      // remove as appropriate

			//additional
			//public studiohdrFlags[] getFlags => FlagsUtils.getFlags<studiohdrFlags>(flags);
			public BSP.SourceBSPStructs.Contents[] getContents => FlagsUtils.getFlags<BSP.SourceBSPStructs.Contents>(contents);
			public string pszName; //((char*)this) + sznameindex;
			public int GetSurfaceProp() => surfacepropLookup;
			public string pszSurfaceProp; //((char*)this) + surfacepropidx;
		}

		/// <summary>Bone. Size: 56 bytes.</summary>
		public struct mstudiobonecontroller_t
		{
			public int bone;   // -1 == 0
			public int type;   // X, Y, Z, XR, YR, ZR, M
			public float start;
			public float end;
			public int rest;   // byte index value at rest
			public int inputfield; // 0-3 user set controller, 4 mouth
								   //public int[] unused;//[8];
		}

		public class virtualmodel_t
		{
			//public void AppendSequences(int group, studiohdr_t pStudioHdr)
			//{
			//	int numCheck = m_seq.Count();

			//	int j, k;

			//	List<virtualsequence_t> seq;

			//	seq = m_seq;

			//	//m_group[group].masterSeq.SetCount(pStudioHdr.numlocalseq);

			//	for (j = 0; j < pStudioHdr.numlocalseq; j++)
			//	{
			//		mstudioseqdesc_t seqdesc = pStudioHdr.pLocalSeqdesc(j);
			//		string s1 = seqdesc.pszLabel();

			//		if (HasLookupTable())
			//		{
			//			k = numCheck;
			//			short index = GetSeqTable()->Find(s1);
			//			if (index != GetSeqTable()->InvalidIndex())
			//			{
			//				k = GetSeqTable()->Element(index);
			//			}
			//		}
			//		else
			//		{
			//			for (k = 0; k < numCheck; k++)
			//			{
			//				const studiohdr_t* hdr = m_group[seq[k].group].GetStudioHdr();
			//				char* s2 = hdr->pLocalSeqdesc(seq[k].index)->pszLabel();
			//				if (!stricmp(s1, s2))
			//				{
			//					break;
			//				}
			//			}
			//		}
			//		// no duplication
			//		if (k == numCheck)
			//		{
			//			virtualsequence_t tmp;
			//			tmp.group = group;
			//			tmp.index = j;
			//			tmp.flags = seqdesc->flags;
			//			tmp.activity = seqdesc->activity;
			//			k = seq.Add(tmp);
			//		}
			//		else if (m_group[seq[k].group].GetStudioHdr().pLocalSeqdesc(seq[k].index)->flags & STUDIO_OVERRIDE)
			//		{
			//			// the one in memory is a forward declared sequence, override it
			//			virtualsequence_t tmp;
			//			tmp.group = group;
			//			tmp.index = j;
			//			tmp.flags = seqdesc->flags;
			//			tmp.activity = seqdesc->activity;
			//			seq[k] = tmp;
			//		}
			//		m_group[group].masterSeq[j] = k;
			//	}

			//	if (HasLookupTable())
			//	{
			//		for (j = numCheck; j < seq.Count(); j++)
			//		{
			//			studiohdr_t hdr = m_group[seq[j].group].GetStudioHdr();
			//			string s1 = hdr.pLocalSeqdesc(seq[j].index).pszLabel();
			//			GetSeqTable().Insert(s1, j);
			//		}
			//	}

			//	m_seq = seq;
			//}
			//public void AppendAnimations(int group, studiohdr_t pStudioHdr );
			//public void AppendAttachments(int ground, studiohdr_t pStudioHdr );
			//public void AppendPoseParameters(int group, studiohdr_t pStudioHdr );
			//public void AppendBonemap(int group, studiohdr_t pStudioHdr );
			//public void AppendNodes(int group, studiohdr_t pStudioHdr );
			//public void AppendTransitions(int group, studiohdr_t pStudioHdr );
			//public void AppendIKLocks(int group, studiohdr_t pStudioHdr );
			//public void AppendModels(int group, studiohdr_t pStudioHdr );
			//public void UpdateAutoplaySequences( studiohdr_t pStudioHdr );

			public virtualgroup_t pAnimGroup(int animation) { return m_group[m_anim[animation].group]; } // Note: user must manage mutex for this
			public virtualgroup_t pSeqGroup(int sequence) { return m_group[m_seq[sequence].group]; } // Note: user must manage mutex for this

			//CThreadFastMutex m_Lock;

			public List<virtualsequence_t> m_seq;
			public List<virtualgeneric_t> m_anim;
			public List<virtualgeneric_t> m_attachment;
			public List<virtualgeneric_t> m_pose;
			public List<virtualgroup_t> m_group;
			public List<virtualgeneric_t> m_node;
			public List<virtualgeneric_t> m_iklock;
			public List<ushort> m_autoplaySequences;
		}

		public class virtualgroup_t
		{
			//public virtualgroup_t() { cache = null; };
			// tool dependant.  In engine this is a model_t, in tool it's a direct pointer
			//void* cache;
			// converts cache entry into a usable studiohdr_t *
			//const studiohdr_t* GetStudioHdr( void ) const;

			public List<int> boneMap;                // maps global bone to local bone
			public List<int> masterBone;         // maps local bone to global bone
			public List<int> masterSeq;          // maps local sequence to master sequence
			public List<int> masterAnim;         // maps local animation to master animation
			public List<int> masterAttachment;   // maps local attachment to global
			public List<int> masterPose;         // maps local pose parameter to global
			public List<int> masterNode;         // maps local transition nodes to global
		}

		public struct virtualsequence_t
		{
			public int flags;
			public int activity;
			public int group;
			public int index;
		}

		public struct virtualgeneric_t
		{
			public int group;
			public int index;
		}
		#endregion
	}
}
